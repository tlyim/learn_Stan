---
title: "State space model of accounting manipulation - Stan"
output: html_notebook
---

```{r}

#library(tidyverse)
library(dplyr)
library(magrittr)

#load previously saved Stan model objects
#load(file = "StanObjects.rda")

library(rstan)
rstan_options(auto_write = TRUE) # avoid recompilation of unchanged Stan programs

# The following can affect distributional computing over a cluster
options(mc.cores = parallel::detectCores())  # 

# The following throws an error in compiling .stan
#Sys.setenv(LOCAL_CPPFLAGS = '-march=native') # For improved execution time but can throw errors for some CPUs

```


# Estimate the simulated model with Stan - misreporting extent 
  (forecasts specified in generated quantities block)
//ignore these lines: 
//  COGS2Rev, SGA2Rev, RnD2Rev with Rev2Rev = unit vector as the intercept)
//   int<lower=0,upper=1> M[N];   // M = 1 for the decision to misreport; = 0 if report honestly  

```{stan output.var=SSM, eval=T}


```

# Simulate data
```{stan output.var=simu_SSM, eval=T}


```


# Simulate data and fit the debug model (also, save Stan model objects) 
```{r}

N = 16*4 #7 number of (yearly) observations of a firm

sd_y = 0.02  # sd of underlying unbiased figures is likely to be industry-specific / business model specific
sd_m = 0.01  # sd of misreporting extent m, which should be restrained by the governance setting (eg, audit committee chair with financial expertise, big 4 auditor, etc)

a = 0.04  # intercept parameter of the AR(1) processs of the underlying unbiased figure
b = 0.6  # slope parameter of the AR(1) processs of the underlying unbiased figure
#set parameters of the data generation process of the misreporting extent m
c = c(-0.07, 0.2)
#c = c(0.1, -0.07, 0.2)
K = length(c)
cvec <- matrix(data = c, nrow = K)  # define column vector as a matrix[N,1]
d = c(0.6, 0.3, 0.1) # fractional reversal of prior-period manipluation by accruals

integrity = 0 #0.8       
# integrity level, between (0,1), of the society, interpreted as likelihood to behave opportunistically
# integrity level of an individual, indiv_integ between (-Inf,Inf), is 
#   affected by a society's general integrity level in a stochastic fashion varying from period to period

#M <- rbinom(N, 1, integrity)   # the decision to misreport earnings

#set.seed(88)  # set the seed for rng to ensure replicability
# covariate matrix X capturing the dis/incentive to misreport
X <- matrix(data = c(#rep(1, N), 
                     rnorm(N, integrity, 0.3), rbinom(N, 1, 0.3)),
            nrow = N)
colnames(X) <- c(#"constant", 
                 "indiv_integ", "downgrade")  
# downgrade = 1 if one or more analysts following the firm downgraded their stock recommendation in the last period
#colnames(Z) <- c("Rev2Rev", "COGS2Rev", "SGA2Rev", "RnD2Rev")

simu_SSM_data <- list(N = N, 
                      K = K,
                      X = X,
                      a = a,
                      b = b, 
                      c = c,
                      sd_y = sd_y,
                      sd_m = sd_m
                      )
# save(simu_SSM_data, file="simu_SSM_data.rda")
# load(file="simu_SSM_data.rda")

# Simulate SSM data
simu_fit <- stan(#model_code = simu_SSM@model_code,
                 file = "simu_SSM.stan",  # Stan program
                 data=simu_SSM_data, iter=1, #seed=987,  
                 chains=1, algorithm="Fixed_param")  

y <- extract(simu_fit)$y[1,]
m <- extract(simu_fit)$m[1,]

D <- m - d[1]*lag(m) - d[2]*lag(m,2L) - d[3]*lag(m,3L)
D[1] = m[1]
D[2] = m[2] - d[1]*m[1]     
D[3] = m[3] - d[1]*m[2] - d[2]*m[1]    

r <- y + D

# Prepare SSM data for estimation using MCMC
#N_new = 3
SSM_data <- list(N = N, 
                 K = K,
                 r = r, 
                 X = X
                 # Z_new = Z[1:N_new,],
                 # N_new = N_new
                 )
# Fit the debug model to make sure the Stan code complies properly 
#fit0_debug <- stan(model_code = SSM@model_code, data = SSM_data, iter = 10, chains = 1)

#save(simu_GP, misreport, file = "StanObjects.rda")
#load(file = "StanObjects.rda")
```

# Fit the full model (by referring to the debug model) to estimate underlying parameters
```{r}

# Run the full model and refer to the debug model to save compilation time 
system.time({
fit1 <- stan( 
  file = "SSM.stan",  # Stan program
  data = SSM_data,    # named list of data
#  model_code = SSM@model_code, 
#  fit = fit0_debug,   # to save compilation time if the debug model was run
  control = list(adapt_delta = 0.99, max_treedepth = 12),    # adjust when there're divergent transitions after warmup
#  chains = 1,             # default is 4 Markov chains
#  cores = 8,
#  init = init, # where init = list(list(mu=...,sigma=...), list(mu=..., sigma=...), ...) 
                # where length of list = number of chains
#  seed = 555,
  iter = 9000,#12000, #500 #2000,            # total number of iterations per chain
  warmup = 2000,          # number of warmup iterations per chain
  refresh = 1000#0          # = 0 means no progress shown
  )
})


#extract(fit1)$y[1,]
#pairs(extract(fit1), pars = c(a, b)) #, y[1], sd_y, m[1], sd_m, c[1], c[2], c[3]))

```

# Summary of the posterior sample 
```{r}

ss_complete_pool <- extract(fit1);
# rho_T <- 5.5, alpha_T <- 3, sigma_T <- 2
print(fit1, probs = c(0.1, 0.5, 0.9), digits = 3) #, probs = c(.05,.95))

# source('stan_utility.R')
# check_all_diagnostics(fit1)

```

```{r}
warnings()
sessionInfo()
```



