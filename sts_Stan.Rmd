---
title: "Structural time series - Stan model"
output: html_notebook
---

```{r}

#library(magrittr)
#library(dplyr)
#library(tidyverse)

#load previously saved Stan model objects
#load(file = "StanObjects.rda")

library(rstan)
rstan_options(auto_write = TRUE) # avoid recompilation of unchanged Stan programs

# The following can affect distributional computing over a cluster
options(mc.cores = parallel::detectCores())  # 

# The following throws an error in compiling .stan
#Sys.setenv(LOCAL_CPPFLAGS = '-march=native') # For improved execution time but can throw errors for some CPUs

```


# Estimate the simulated model with Stan - misreporting extent 
  (forecasts specified in generated quantities block)
//ignore these lines: 
//  COGS2Rev, SGA2Rev, RnD2Rev with Rev2Rev = unit vector as the intercept)
//   int<lower=0,upper=1> M[N];   // M = 1 for the decision to misreport; = 0 if report honestly  

```{stan output.var=SSM, eval=T}
// Focus on the time series of only one firm
// The observations are reported accounting figures, say COGS, (scaled by Rev, total revenue) a vector r of length N (years).
// The covariates are a matrix capital X with K column vectors, incl a unit vector, capturing the  
//   dis/incentives of misreporting the underlying unbiased figures (y) as the observed reported firgures
data {
  int<lower=0> N; // number of observations (for different years)
  int<lower=0> K; // number of coefficents for the column vectors in covariate matrix X
  vector[N] r; // reported figures (scaled by Rev, total revenue)
  matrix[N,K] X; // covariates (capturing the dis/incentives of misreporting)

// forecasts  
//  int<lower=0> N_new; // number of predictions
//  matrix[N_new,K] X_new; // 
}
transformed data {
// GP data
}
parameters {
  vector[N] y; // underlying unbiased figures (scaled by Rev, total revenue)
  real a; // intercept coefficient (drift) of the AR(1) process of the unbiased figure y[n]
  real b; // slope coefficient of the AR(1) process of y[n]
  vector[K] c; // coefficients of the K covariates in matrix X
  real<lower=0> sd_y; // sd of the underlying unbiased figures (vector y)
  real<lower=0> sd_m; // sd of the misreporting extents (vector m = r - y)
// real<lower=0,upper=1> integrity;     // integrity level of the society affecting the decision to misreport or not
//  vector[N] integrity;     // integrity level of each CEO affecting the decision to misreport or not
}
transformed parameters {
  vector[N] m; // misreporting extent in the reported figures 
  m = r - y;

//  real ilogodds;     // log odds of the society integrity level
//  ilogodds = logit(integrity);   
}
model {

//  for (n in 2:N)
//    y[n] ~ normal(alpha + beta * y[n-1], sigma);
  y[2:N] ~ normal(a + b * y[1:(N - 1)], sd_y);
  
// c ~ cauchy(0, 2.5); // common prior for each b[K]
  m ~ normal(X*c, sd_m);  // shouldn't good governance restrict |m| or m^2 ? Then impact of X is on sd_m
//  M ~ bernoulli_logit(ilogodds); 

}
generated quantities {

//  vector[N_new] r_new;
//  for (n in 1:N_new)
//    r_new[n] = normal_rng(Z_new[n] * b, sd_r);
}

```

# Simulate data
```{stan output.var=simu_SSM, eval=T}
data {
  int<lower=0> N; // number of observations (for different years)
  int<lower=0> K; // number of coefficents for the column vectors in covariate matrix X
  matrix[N,K] X; // covariates (capturing the dis/incentives of misreporting)

  real a; // intercept coefficient (drift) of the AR(1) process of the underlying unbiased accounting figure y[n]
  real b; // slope coefficient of the AR(1) process of y[n]
  vector[K] c; // coefficients of the K covariates in matrix X
  real<lower=0> sd_y; // sd of the underlying unbiased figure (vector y)
  real<lower=0> sd_m; // sd of the misreporting extent (vector m = r - y)
}
transformed data {}
parameters {}
model {}
generated quantities {
  vector[N] y; // underlying unbiased figures  
  vector[N] m; // misreporting extent in the reported figures 
//  vector[N] r; // reported figures (scaled by Rev, total revenue)

  y[1] = normal_rng(a/(1-b), sd_y);   // y should be nonnegative for Rev and nonpositive for Costs
// Perhaps best to model y as always positive, with IsCost = 1, 0 to indicate Cost or Rev item 
//  y[2:N] = normal_rng(a + b * y[1:(N - 1)], sd_y);
//  m = normal_rng(X*c, sd_m);
//  r = y + m; 
  m[1] = normal_rng(X[1]*c, sd_m); 
//  r[1] = y[1] + m[1];     // should be more efficient to use R to create r from y, m
  for (n in 2:N) {
    y[n] = normal_rng(a + b * y[n-1], sd_y);
    m[n] = normal_rng(X[n]*c, sd_m); 
//    r[n] = y[n] + m[n];
  }
}
```


```{r}

```


# Simulate data and fit the debug model (also, save Stan model objects) 
```{r}

N = 99*5#4 + 50  #9999

#set.seed(88)  # set the seed for random generation to ensure replicability

# Z matrix is composed of the columns of earnings components
Z <- matrix(data = c(rep(1, N), rnorm(N), rnorm(N), rnorm(N)), 
            nrow = N)
colnames(Z) <- c("Rev2Rev", "COGS2Rev", "SGA2Rev", "RnD2Rev")

#set actual parameters of the data generation process of the reported earnings (to total revenue ratio) 
a = c(0.9, -0.4, -0.2, -0.05)
avec <- matrix(data = a, nrow = length(a))  # define column vector as a matrix[N,1]

# Simulate the earnings based on a linear model (Later, this model will be estimated with observed data)
sd_r = 0.15
r <- rnorm(N, mean = (Z %*% avec), sd = sd_r)  # reported company earnings, scaled by Rev, total revenue)

mod_OLS <- lm(r ~ . + 0, data = data.frame(r, Z))  # + 0 to remove intercept as Rev2Rev is the unit vector for intercept
summary(mod_OLS)

integrity = 0.8       # integrity level of the society, interpreted as likelihood to behave opportunistically
M <- rbinom(N, 1, integrity)   # the decision to misreport earnings


# Simulate GP data
rho_T <- 5.5   # set true parameters for the exponential kernel of the GP
alpha_T <- 3
sigma_T <- 2

g = 1 # approx. about g times of N
G_total = g*(N+1) + 1
t_total <- 20 * (0:(G_total - 1)) / (G_total - 1) - 10   # rescale the range of z to [-10,10]

sim_GP_data <- list(rho=rho_T, 
                  alpha=alpha_T, 
                  sigma=sigma_T, 
                  N=G_total, 
                  x=t_total)

simu_fit <- stan(model_code = simu_GP@model_code, data=sim_GP_data, iter=1, 
            chains=1, algorithm="Fixed_param")  #seed=987,  
                      

m_total <- extract(simu_fit)$y[1,]  # misreporting extent = the sample y of from the true realization GP f
# true_realization <- data.frame(f_total = extract(simu_fit)$f[1,], 
#                                t_total = t_total)
observed_t <- c(g*(1:N))  # Get N observed points evenly over the range [-10,10]
t <- t_total[observed_t]     
m <- m_total[observed_t]


# Prepare simulated earnings management (EM) data for estimation using MCMC
N_new = 3
sim_EM_data <- list(N = N, 
                 K = length(a),
                 r = r, 
                 Z = Z,
                 M = M,
                 G = N,
                 t = t,
                 m = m,
                 Z_new = Z[1:N_new,],
                 N_new = N_new
                 )

# Fit the debug model to make sure the Stan code complies properly 
fit0_debug <- stan(model_code = misreport@model_code, data = sim_EM_data, iter = 10, chains = 1)

#save(simu_GP, misreport, file = "StanObjects.rda")
#load(file = "StanObjects.rda")
```

# Fit the full model (by referring to the debug model) to estimate underlying parameters
```{r}

# Run the full model and refer to the debug model to save compilation time 
system.time({
fit1 <- stan( 
#  file = "misreport.stan",  # Stan program
  data = sim_EM_data,    # named list of data
  fit = fit0_debug,   # to save compilation time if the debug model was run
  control = list(adapt_delta = 0.90),    # adjust when there're divergent transitions after warmup
#  chains = 1,             # default is 4 Markov chains
#  cores = 8,
#  init = init, # where init = list(list(mu=...,sigma=...), list(mu=..., sigma=...), ...) 
                # where length of list = number of chains
#  seed = 555,
  iter = 300, #500 #2000,            # total number of iterations per chain
#  warmup = 1000,          # number of warmup iterations per chain
  refresh = 100#0          # = 0 means no progress shown
  )
})

```

# Summary of the posterior sample 
```{r}

ss_complete_pool <- extract(fit1);
# rho_T <- 5.5, alpha_T <- 3, sigma_T <- 2
print(fit1, probs = c(0.1, 0.5, 0.9), digits = 3) #, probs = c(.05,.95))

source('stan_utility.R')
check_all_diagnostics(fit1)

```

```{r}
warnings()
sessionInfo()
```



